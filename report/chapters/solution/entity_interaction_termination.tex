\newpage
\subsection{Terminazione distribuita}\label{sec:distributed_termination}

La Terminazione del Sistema progettata, sfrutta la presenza dell'entità di Controllo Centrale, la quale, per ciascun nodo di simulazione, invia un messaggio di terminazione. Tale meccanismo deve portare ad uno stato consistente. Per poter terminare l'attività di ciascun nodo di simulazione, è possibile in prima istanza inviare un messaggio di terminazione ai pool di thread \ttt{Train\_Pool} e \ttt{Traveler\_Pool}, in modo tale che ciascun thread in attesa sulla rispettiva coda interrompa l'attesa e concluda la propria esecuzione. Tuttavia questo da solo non è sufficiente ne a garantire che tutti i thread terminino la propria esecuzione, ne che lo stato risultante sarà consistente. In primo luogo infatti, ci possono essere thread in attesa su una guardia booleana, la quale può non essere più riaperta a causa della terminazione del thread incaricato. \'E il caso dell'attesa per l'accesso ad una Piattaforma da parte di un Treno: infatti nel momento in cui il thread rappresentante il Treno che occupa la Piattaforma termina la propria esecuzione, nessun'altra entità provvederà ad aprire la guardia booleana per permettere l'accesso. Nonostante lo stato risulti consistente (un Treno occupa una Piattaforma, altri Treni sono in attesa), il sistema non può considerarsi terminato. Risulta quindi opportuno prevedere un meccanismo capace di interrompere l'attesa su guardia, discriminando il caso in cui essa avvenga per terminazione. In tutti gli altri casi in cui si può avere attesa (accesso ad un Segmento), la semantica descritta nelle sezioni precedenti garantisce che i Treni completeranno le operazioni in modo tale da non rimanere bloccati su guardie booleane (evitando così situazioni di Stallo).

	In secondo luogo, ci possono essere problemi legati alla creazione di Ticket, la quale coinvolge la Biglietteria Centrale e i nodi di simulazione: ad esempio, se supponiamo che i nodi di simulazione abbiano ricevuto un messaggio di terminazione e che alcuni di essi abbiano già terminato la propria esecuzione, la Biglietteria Centrale sarà impossibilitata a contattarli, generando un messaggio di errore sia in fase di creazione, sia in fase di consegna del Ticket creato. Questo può portare a situazioni non consistente come per esempio quella in cui un Viaggiatore in attesa (non attiva poiché il processo è asincrono, e quindi teminabile) di un Ticket può non riceverlo, ne ricevere un eventuale messaggio di errore. \'E chiaro che in una ipotetica ripresa dell'esecuzione, il Viaggiatore rimarrà inattivo.
	Per ovviare a problemi di questo tipo, la terminazione si può svolgere nel modo seguente: definiamo \ttt{Marker} un messaggio speciale utilizzato per indicare l'inizio della procedura di terminazione. 
	\begin{itemize}
		\item Il Controller Centrale inizia la procedura di terminazione e invia un messaggio \ttt{Marker} alla Biglietteria Centrale.
		\item Una volta ricevuto tale messaggio, la Biglietteria Centrale inizia a memorizzare in una coda FIFO tutti i messaggi di richiesta di Creazione di un Biglietto che non siano un altro \ttt{Marker}. Inoltre, completa le richieste di creazione di un Ticket in corso e memorizza i messaggi in uscita relativi a tali richieste su una coda di output. Una volta terminate le operazioni in corso, invia un messaggio \ttt{Marker} al Controller Centrale.
		\item Il Controller invia quindi un \ttt{Marker} a tutti i nodi di simulazione, i quali:
			\begin{itemize}
				\item ultimano le operazioni in corso;
				\item inviano un messaggio di \ttt{Unbind} al Name Server;
				\item inviano un messaggio di risposta al Controller Centrale;
				\item infine terminano.
			\end{itemize}
		\item Il Controller una volta ottenuta risposta da tutti i nodi di simulazione, invia un nuovo \ttt{Marker} alla Biglietteria Centrale, la quale, memorizzato lo stato delle code di input e output, termina.
		\item Il Controller Centrale termina la propria esecuzione.
	\end{itemize}
