\newpage
\chapter {Specifica della soluzione Realizzata}

Di seguito verrà fornita una descrizione dell'architettura del progetto realizzato, e in particolare verrà descritto come le soluzioni progettate sono state realizzate nella pratica. Dove necessario, verranno riportati listati di codice sorgente a supporto della descrizione.

\section{Simulazione}

	\begin{figure}[htbp]
		\includegraphics[scale=0.39,trim= 100mm 0mm 0mm 0mm]{imgs/Simplified_Class_Diagram.pdf}
		\caption{\footnotesize{Diagramma delle classi che illustra le componenti e le relazioni più significative che coinvolgono la simulazione.}}
		\label{img:class_diagram}
	\end{figure}

L'architettura di massima adottata per la realizzazione del core di simulazione, è visibile nel diagramma delle classi in figura \ref{img:class_diagram} nel quale, per brevità, sono stati riportati solo le informazioni più significative.
	Viene ora fornita una breve descrizione delle varie componenti che sono state utilizzate, procedendo per Package. Nelle sezioni seguenti si utilizzeranno le nozioni di \ii{Task} e \ii{Tipo protetto} definite dal linguaggio \ii{Ada}, utilizzato per l'implementazione, e verrà mostrato come le soluzioni presentate nel capitolo precedente sono state tradotte con strumenti di linguaggio.

	\subsection{Message\_Agent}
	
	Il package \ttt{Message\_Agent} fornisce un'interfaccia per l'invio di messaggi remoti. Esso contiene una classe singleton \ttt{Message\_Agent\_Type}, la quale possiede i seguenti campi dato:
	\begin{description}
		\item \ttt{- Client\_Agent : YAMI.Agents.Agent\_Access} \\
		Campo dati privato di tipo \ttt{YAMI.Agents.Agent\_Access} che contiene una istanza di Agente fornito dalla libreria \ii{Yami4}, e che viene utilizzato per l'invio e la ricezione di messaggi remoti.
		\item \ttt{- Handlers\_Map : Map} \\
		Hash-map privata, la quale associa a chiavi di tipo \ttt{String}, valori di tipo \ii{riferimento a procedura}; essa viene utilizzata per associare a ciascun servizio offerto dall'oggetto \ttt{Client\_Agent} un handler per la sua gestione.
	\end{description}
	
	Essa offre inoltre i seguenti metodi:
	
	\begin{description}
		\item \ttt{+ Listen\_To(Server\_Address)} \\
		Indica all'oggetto \ttt{Client\_Agent} di rimanere in ascolto presso l'indirizzo \ttt{Server\_Address}, attraverso il quale riceverà tutti i messaggi destinati al nodo. Nella fase di registrazione dell'oggetto remoto, viene definito un handler per la ricezione dei messaggi, il quale effettua il dispatching di ciascun messaggio ricevuto invocando la procedura corrispondente al servizio richiesto, definita nella mappa \ttt{Handlers\_Map}.
		
		\item \ttt{+ Close()} \\
		Chiude la connessione dell'oggetto \ttt{Client\_Agent}.
		
		\item \ttt{+ Send\_Message(\\
			Destination\_Address:String,\\
			Object:String,\\
			Service:String,\\
			Params:YAMI.Parameters.Parameters\_Collection,\\
			Callback)}\\
		Invia un messaggio all'oggetto remoto indicato da \ttt{Object} all'indirizzo \ttt{Destination\_Address}, richiedendo il servizio \ttt{Service}, e con i parametri indicati da \ttt{Params}. Se non nulla, la funzione di callback \ttt{Callback} viene invocata alla ricezione del messaggio di risposta, altrimenti quest'ultimo viene ignorato.
		
		\item \ttt{+ Send\_One\_Way(\\
			Destination\_Address : String,\\
			Object 				: String,\\
			Service 			: String,\\
			Params 				: YAMI.Parameters.Parameters\_Collection)}\\
		Metodo simile a \ttt{Send\_Message}, solo che non rimane in attesa della risposta al messaggio inviato.
	\end{description}
	
	Nessun meccanismo di serializzazione delle richieste è stato adottato, in quanto esso è già operato dagli oggetti della libreria \ii{Yami4}.
	
	\subsection{Central\_Controller\_Interface}
	
	Il package \ttt{Central\_Controller\_Interface} fornisce un'interfaccia per permettere alle entità della simulazione di inviare un evento di notifica all'oggetto remoto \ttt{central\_controller}. A tal proposito sono messi a disposizione le procedure \ttt{Set\_Train\_Status} e \ttt{Set\_Traveler\_Status}, le quali effettuano il marshalling dei dati in ingresso (in formato \ttt{JSON}) e inviano un messaggio remoto mediante il metodo \ttt{Send\_One\_Way} offerto dall'unica istanza di \ttt{Message\_Agent\_Type}.
	
	\subsection{Central\_Office\_Interface}
	
	Il package \ttt{Central\_Office\_Interface} fornisce un'interfaccia per permettere la comunicazione con la Biglietteria Centrale, mediante l'invio di messaggi all'oggetto remoto \ttt{central\_ticket\_server}.
	
		\begin{description}
			\item \ttt{+ Create\_Ticket( \\
				From : String,\\
				To	 : String,\\
				Traveler\_Index: Integer)} \\
			Richiede la creazione di un Biglietto inviando un messaggio remoto mediante il metodo \ttt{Send\_Message} offerto dall'unica istanza di \ttt{Message\_Agent\_Type}. Non viene specificata una procedura di callback, in quanto il risultato verrà inviato dalla Biglietteria Centrale una volta calcolato il Biglietto.
			
			\item \ttt{+ Validate(\\
				The\_Ticket:Ticket,\\
				Callback:access procedure(The\_Ticket:Ticket,Response:Boolean))}\\
			Richiede la validazione di un Biglietto inviando un messaggio remoto mediante il metodo \ttt{Send\_Message} offerto dall'unica istanza di \ttt{Message\_Agent\_Type}. La richiesta è sincrona, e la risposta viene quindi elaborata e viene invocata la procedura \ttt{Callback} passando come parametri i risultati estratti.
			
			\item \ttt{+ Update\_Run(\\
				Route\_Index:Integer,\\
				Current\_Run:Integer,\\
				Callback:access procedure(...))}\\ 
			Invia un messaggio remoto per comunicare l'aggiornamento della corsa corrente \ttt{Current\_Run} per il percorso \ttt{Route\_Index}. Nel caso in cui la corsa sia l'ultima delle $N$ mantenute, viene creata una nuova Time Table per il percorso \ttt{Route\_Index} dalla Biglietteria Centrale che viene restituito al chiamante. Nel caso in cui essa venga ricevuta (in formato \ttt{JSON}), viene effettuato l'unmarshalling e creata l'istanza corrispondente di \ttt{Time\_Table\_Type} da sostituire a quella corrente.
			
			\item \ttt{+ Load\_Time\_Tables(\\
				Callback:access procedure(Table:Time\_Table\_Array\_Ref))}\\
			Invocazione di un messaggio remoto per richiedere l'insieme delle Time Tables per tutti i percorsi.
				
		\end{description}
	
	\subsection{Name\_Server\_Interface}
	
	Package che fornisce un'interfaccia remota per la comunicazione con il Server dei Nomi che mantiene la lista delle Regioni di simulazione. Esso fornisce le seguenti procedure:
	\begin{description}
		\item \ttt{+  Bind(\\
		Name\_Server : String,\\
		Node\_Name 	: String,\\
		Address	: String)} \\
		
	Permette di registrare presso il Server dei Nomi che l'entità remota \ttt{Node\_Name} è disponibile alla locazione indicata da \ttt{Address}. 
	
	\item \ttt{+  Resolve(\\
		Name\_Server : String,\\
		Node\_Name 	: String),\\
		Callback : access procedure(Result:String)} \\
		
		Permette di richiedere al Server dei Nomi la risoluzione della locazione alla quale si trova l'entità \ttt{Node\_Name}. Una volta che la risposta è disponibile, viene invocata la procedura di callback \ttt{Callback}. 
				
	\end{description}
	
	Per entrambe le procedure, viene inviato un messaggio all'oggetto remoto identificato da \ttt{name\_server}, mediante il metodo \ttt{Send\_Message} di \ttt{Message\_Agent\_Type}, al quale viene passato una procedura di callback che estrae il campo \ttt{address} dal messaggio di ritorno e lo passa all'invocazione di \ttt{Callback}. Presso il package viene mantenuta una hash-map, la quale permette di memorizzare le destinazioni risolte, in modo da limitare l'invio di messaggi remoti.
	
	\subsection{Remote\_Station\_Interface}
	
	Il package \ttt{Remote\_Station\_Interface} espone un insieme di procedure che permettono l'invio di messaggi remoti tra i Nodi che cooperano alla simulazione, che saranno diretti agli oggetti remoti \ttt{message\_handler}.
	\begin{description}
		
		\item \ttt{+ Send\_Train(\\
			Train\_Descriptor\_Index:Integer,\\
			Station:Integer,\\
			Platform:Integer,\\
			Next\_Node\_Name:String)}\\ 
		Tale procedura permette l'invio di un messaggio remoto al Nodo identificato da \ttt{Next\_Node\_Name} per effettuare il trasferimento del Treno indicato da \ttt{Train\_Descriptor\_Index} presso la Stazione \ttt{Station}, Piattaforma \ttt{Platform}. 
		
		\item \ttt{+ Train\_Left\_Message(\\
			Train\_Descriptor\_Index:Integer,\\
			Station:Integer,\\
			Platform:Integer,\\
			Next\_Node\_Name:String)}\\ 
		Questa procedura permette l'invio di un messaggio remoto al Nodo identificato da \ttt{Next\_Node\_Name} per indicare la partenza del Treno \ttt{Train\_Descriptor\_Index} dalla Piattaforma \ttt{Platform} della Stazione \ttt{Station}.
		
		\item \ttt{+ Send\_Traveler\_To\_Leave(\\
			Traveler\_Index:Integer,\\
			Train\_ID:Integer,\\
			Station:Integer,\\
			Platform:Integer,\\
			Node\_Name:String)}\\
		Permette l'invio di un messaggio remoto al Nodo identificato da \ttt{Node\_Name} per aggiungere il Viaggiatore \ttt{Traveler\_Index} in attesa presso la Piattaforma \ttt{Platform} della Stazione \ttt{Station} dell'arrivo del Treno \ttt{Train\_ID} per poter lasciare tale Stazione.
		
		\item \ttt{+ Wait\_For\_Train\_To\_Arrive(\\
			Next\_Station:Integer,\\
			Traveler\_Manager\_Index:Integer,\\
			Train\_ID:Integer,\\
			Destination\_Platform\_Index:Integer,\\
			Next\_Region:String)}\\
		Permette l'invio di un messaggio remoto al Nodo identificato da \ttt{Node\_Name} per aggiungere il Viaggiatore \ttt{Traveler\_Index} in attesa presso la Piattaforma \ttt{Platform} della Stazione \ttt{Station} dell'arrivo del Treno \ttt{Train\_ID} per poter arrivare presso tale Stazione.
		
	\end{description}
	
	\subsection{Queue}
	
	Il package \ttt{Queue} contiene la definizione di alcuni tipi di code utilizzati nell'intera simulazione:
		\begin{description}
			\item {\ttt{Terminable\_Queue}} \\
			Tipo \ii{protetto} costruito come \ii{wrapper} della coda standard offerta dal package \ttt{Ada.Containers.Unbounded\_Synchronized\_Queues}, e che permette di interrompere l'attesa sulla guardia Booleana definita per l'entry \ttt{Dequeue}, la quale rimane chiusa nel caso in cui non vi siano più elementi al suo interno.
			Esso e definisce l'entry
			\begin{center}
				\ttt{Dequeue(Element:out  Element\_Type,Terminated:out  Boolean)}
			\end{center}
		
		con guardia Booleana: \ttt{Termination or Q.Current\_Use > 0}, dove \ttt{Q} è una coda fornita dalle librerie standard di linguaggio, \ttt{Current\_Use} è una funzione che restituisce il numero di elementi all'interno della coda, e \ttt{Termination} è un campo dati Booleano della risorsa protetta. In questo modo nel caso in cui il valore di \ttt{Termination} sia \ttt{True} l'attesa su coda viene interrotta, e viene restituito al chiamante il valore \ttt{True} attraverso il parametro passato per riferimento \ttt{Terminated}, altrimenti la coda restituisce anche il valore del primo elemento rimosso dalla coda.
		
		Per poter attribuire al campo dati \ttt{Termination} il valore \ttt{True}, viene fornita la procedura protetta \ttt{Stop}.
			
			\item {\ttt{Limited\_Simple\_Queue}} \\
			Tipo di coda non thread-safe, di dimensione limitata, realizzato mediante un array di elementi, e che fornisce un'interfaccia composta dai metodi:
			\begin{itemize}
				\item \ttt{Enqueue(Element:Element\_Type)} per accodare un nuovo elemento;
				\item \ttt{Dequeue(Element:out Element\_Type)} per rimuovere l'elemento dalla testa della coda;
				\item \ttt{Get(Index:Integer)} per ottenere il valore dell'elemento nella posizione \ttt{Index};
			\end{itemize}
			
			\item {\ttt{Unlimited\_Simple\_Queue}} \\
			Tipo di coda non thread-safe di dimensione illimitata, realizzato mediante un oggetto di tipo \ttt{Vector} definito dalle librerie standard \ttt{Ada.Containers.Vectors}. Esso presenta un'interfaccia del tutto simile a quella offerta dal tipo \ttt{Limited\_Simple\_Queue}, alla quale aggiunge il metodo \ttt{Is\_Empty : Boolean} che indica se la coda è vuota. 
			
		\end{description}
	
	\subsection{Generic\_Operation\_Interface}
	
	Package che contiene la definizione di una interfaccia \ttt{Operation\_Interface}, la quale espone un unico metodo \ttt{Do\_Operation()}. Essa rappresenta una generica operazione. Viene definito inoltre un tipo puntatore ad operazione generica \ttt{Any\_Operation}.
	
	\subsection{Traveler\_Pool}
	
	Il package {Traveler\_Pool} realizza il meccanismo per l'esecuzione delle entità Viaggiatore descritto in sezione \ref{subsec:traveler_def}. Esso mantiene 
	\begin{itemize}
		\item una coda \ttt{Operations\_Queue} di puntatori di tipo \ttt{Any\_Operation} a operazioni. Tale coda è di tipo \ttt{Terminable\_Queue}, definito nel package \ttt{Queue}.
		\item la definizione di un tipo record \ttt{Traveler\_Pool\_Type} contenente un array di oggetti task \ttt{Executor}, di dimensione fissata in fase di creazione.
		Ciascun task di tipo \ttt{Executor} eseguirà semplici operazioni ciclicamente:
		\begin{itemize}
			\item Estrae il primo elemento dalla coda \ttt{Operations\_Queue} mediante il metodo \ttt{Dequeue} da essa offerto. 
			\item Nel caso in cui il valore del parametro \ttt{Terminated} passato per riferimento abbia il valore \ttt{True}, allora viene interrotto il ciclo di operazioni.
			\item Altrimenti, viene invocato il metodo \ttt{Do\_Operation} sul puntatore ad operazione estratto.
		\end{itemize}
	\end{itemize}
	
	\subsection{Ticket}
	
	Package che contiene la definzione di un Biglietto. Esso definisce infatti il tipo record \ttt{Ticket\_Type}, il quale è composto da un campo intero \ttt{Next\_Stage} che indica la tappa corrente del percorso descritto dal Biglietto, e un puntatore ad un array di Tappe, ovvero di oggetti di tipo \ttt{Ticket\_Stage}. Quest'ultimi mantengono le seguenti infomazioni:
		\begin{itemize}
			\item \ttt{Start\_Station} : Indice della Stazione di partenza;
			\item \ttt{Next\_Station} : Indice della prossima Stazione;
			\item \ttt{Train\_ID} : Identificativo del Treno da utilizzare per raggiungere la stazione \ttt{Next\_Station};
			\item \ttt{Start\_Platform\_Index} : Indice della Piattaforma di partenza;
			\item \ttt{Destination\_Platform\_Index} : Indice della Piattaforma di destinazione;
			\item \ttt{Region} : Nome della regione nella quale si colloca la stazione \ttt{Next\_Station};
		\end{itemize}
	Il package fornisce inoltre le funzioni necessarie per effettuare marshalling e unmarshalling degli oggetti di tipo \ttt{Ticket\_Type} in/dal formato \ttt{JSON}.
	
	\subsection{Traveler}
	
	Package che contiene la definizione del tipo rappresentante un Viaggiatore. In esso infatti viene definito il tipo record \ttt{Traveler\_Manager}, formato dai campi:
		\begin{itemize}
			\item \ttt{Next\_Operation} : Indice della prossima operazione da eseguire;
			\item \ttt{Destination} : Nome della stazione di destinazione;
			\item \ttt{Start\_Station} : Nome della stazione di partenza;
			\item \ttt{Start\_Region} : Regione di patenza;
			\item \ttt{Traveler} : Campo di tipo record che contiene alcuni dati relativi al Viaggiatore, come nome e cognome.
			\item \ttt{Ticket} : Riferimento ad un oggetto di tipo \ttt{Ticket\_Type}.
		\end{itemize}
	Il package \ttt{Traveler} contiene inoltre le funzioni necessarie per effettuare marshalling e unmarshalling secondo il formato \ii{JSON}.
	
	\subsection{Regional\_Ticket\_Office}
	
	Il package \ttt{Regional\_Ticket\_Office} mantiene una tabella \ttt{Paths}, la quale per ciascuna Stazione della Regione corrente, definisce i percorsi più brevi per raggiungere ciascuna altra destinazione nella Regione. Esso inoltre espone la seguente interfaccia:
	\begin{description}
		\item \ttt{+ Create\_Ticket(From:String,To:String) : Ticket\_Type} \\
	Crea un istanza di oggetto \ttt{Ticket\_Type} che rappresenta un biglietto per raggiungere la destinazione \ttt{To} a partire da \ttt{From} nella regione corrente. Essa realizza l'algoritmo di creazione di un Biglietto descritto in sezione \ref{subsubsec:ticket_creation}.
		\item \ttt{+ Get\_Ticket (Traveler\_Index:Integer,From:String,To:String)} \\
	La procedure si occupa dell'effettiva creazione del Biglietto (oggetto di tipo \ttt{Ticket\_Type}). Tale procedura effettua un controllo: se le Stazioni \ttt{From} e \ttt{To} sono contenute all'interno della Regione corrente, allora procede alla creazione del Biglietto vero e proprio attraverso la funzione \ttt{Create\_Ticket}, che viene quindi assegnato al Viaggiatore di indice \ttt{Traveler\_Index}; successivamente viene inserita l'operazione \ttt{TICKET\_READY} nella coda di operazioni di \ttt{Traveler\_Pool}. Se invece la Stazione di destinazione \ttt{To} non è contenuta nella Regione corrente, allora viene richiesta la creazione del Biglietto alla Biglietteria Centrale attraverso l'interfaccia \ttt{Central\_Office\_Interface}.
	\end{description}
	
	Il package \ttt{Regional\_Ticket\_Office} contiene inoltre la procedura \ttt{Init\_Path\_Map} utilizzata per caricare la mappa contenente i percorsi più brevi, usata dall'algoritmo di creazione del Biglietto. 
	
	\subsection{Train}
	
	Il package \ttt{Train} contiene la definizione del tipo \ttt{Train\_Descriptor}, record contenente tutti i dati che caratterizzano una entità Treno, e alcune funzioni necessarie ad effettuare la conversione da JSON a oggetto \ttt{Train\_Descriptor} e viceversa.
	I campi principali del record \ttt{Train\_Descriptor} sono:
	\begin{itemize}
		\item \ttt{Id}: identificativo univoco del Treno.
		\item \ttt{Speed}: Velocità di percorrenza Corrente.
	    \item \ttt{Max\_Speed}: Velocità massima raggiungibile dal Treno.
	    \item \ttt{Current\_Station} Indice della stazione corrente.
	    \item \ttt{Route\_Index}: Indice del Percorso assegnato al Treno.
	    \item \ttt{Next\_Stage}: Prossima tappa del Percorso assegnato.
	    \item \ttt{Sits\_Number}: Numero di posti a sedere.
	    \item \ttt{Occupied\_Sits}: Numero di posti occupati correntemente.
		\item \ttt{T\_Type}: Indica il tipo di Treno, tra \ttt{FB} e \ttt{REGIONAL}.
		\item \ttt{Start\_Node}: Regione dalla quale il Treno parte.
	\end{itemize}
	
	Tali descrittori sono memorizzati in un array \ttt{Trains} presso il package \ttt{Trains}, in modo tale da poter essere acceduti in modo diretto dalle varie componenti del sistema.
	
	\subsection{Train\_Pool}
	
	Il package \ttt{Train\_Pool} definisce il pool di Task, che serve ad eseguire le operazioni previste per i Treni. Esso mantiene due code (di tipo \ttt{Terminable\_Queue}) di valori interi, una per ciascuna categoria di Treno, nelle quali verranno inseriti gli indici dell'array di descrittori \ttt{Trains.Trains}, e definisce il tipo Task \ttt{Train\_Executor\_Task}, il quale effettua le seguenti operazioni ciclicamente:
	\begin{itemize}
		\item Preleva da una delle due code il prossimo indice dell'array di descrittori. 

\begin{lstlisting}
...
Trains.Queue.Dequeue(
	To_Get      => Current_Descriptor_Index,
	Terminated  => Terminated);
...
\end{lstlisting}

		\item Effettua la partenza dalla stazione corrente all'orario previsto dalla Time Table per il percorso assegnato al Treno.
\begin{lstlisting}
...
delay until Time_To_Wait;
Environment.Stations(Start_Station).Leave(
	Descriptor_Index => Current_Descriptor_Index,
	Platform_Index   => Start_Platform,
	-- Azione da intraprendere al momento della 
	-- partenza, definita dalla tappa corrente
	-- del percorso
	Action           => Leave_Action);
...
\end{lstlisting}
		 
		\item Richiede l'accesso al prossimo Segmento:

\begin{lstlisting}
...
Segments.Segments(Next_Segment).Enter(
	Current_Descriptor_Index,
	Max_Speed,
	Leg_Length);
...
\end{lstlisting}		
		\item Una volta ottenuto l'accesso, notifica la partenza del Treno al Controller Centrale mediante la procedura \ttt{Set\_Train\_Left\_Status} di \\\ttt{Central\_Controller\_Interface} e simula la percorrenza nel Segmento con il costrutto:

\begin{lstlisting}
...
delay Duration (Time_In_Segment);
...
\end{lstlisting}
		
		\item Richiedi l'uscita dal Segmento. 

\begin{lstlisting}
...
Segments.Segments(Next_Segment).Leave(
		Current_Descriptor_Index);
...
\end{lstlisting}	
	
		\item Richiede l'accesso alla prossima Stazione.

\begin{lstlisting}
...
Environment.Stations(Next_Station).Enter(...);
...
\end{lstlisting}		

		\item Passa alla prossima Tappa del Percorso e inserice l'indice del Descrittore nella coda apposita.

\begin{lstlisting}
...
Trains.Trains(Current_Descriptor_Index).Next_Stage := 
		Trains.Trains(Current_Descriptor_Index).Next_Stage + 1;
...
\end{lstlisting}

	\end{itemize}
	
	L'esecuzione dei Task viene interrotta quando l'operazione di Dequeue nelle code di indici di Descrittori di Treni restituisce \ttt{Terminated=True}. Per permettere invece l'interruzione delle operazioni in corso nel caso in cui l'accesso alla prossima Stazione comporti il trasferimento remoto del Treno indicato da \ttt{Current\_Train\_Descriptor}, viene utilizzata l'eccezione \ttt{Stop\_Train\_Execution} definita nel package \ttt{Remote\_Station\_Interface}.
	
	
	\subsection{Segment}
	
	Il package \ttt{Segment} contiene la definizione del tipo \ttt{Segment\_Type}, \ii{risorsa protetta} che rappresenta una il segmento di congiunzione tra due Stazioni introdotto in sezione \ref{subsec:segment_def}. Esso contiene i seguenti campi dato:
	\begin{itemize}
		
		\item \ttt{Id}: Identificativo univoco del Segmento;
		\item \ttt{Segment\_Max\_Speed}: Velocità massima di percorrenza del Segmento;
		\item \ttt{Current\_Max\_Speed}: Velocità massima alla quale i Treni percorrono il Segmento;
		\item \ttt{Free}: Indica lo stato di occupazione del Segmento, se \ttt{True} il Segmento è da considerarsi occupato, altrimenti libero.
		\item \ttt{Segment\_Length}: Lunghezza del Segmento;
		
		\item \ttt{Current\_Direction}: Direzione di percorrenza corrente;
		
		\item \ttt{Running\_Trains\_Queue}: Coda di tipo \ttt{Unlimited\_Simple\_Queue} che contiene gli identificativi dei Treni in transito;
		\item \ttt{Trains\_Number}: Mantiene il numero di Treni attualmente in transito;
		
		
		\item \ttt{First\_End,Second\_End}: Stazioni che sono collegate dal Segmento; 
		
		\item \ttt{Can\_Enter\_First\_End, Can\_Enter\_Second\_End}: Variabili booleane utilizzati come guardie per le enties \ttt{Retry\_First\_End} e \ttt{Retry\_Second\_End}.
		
		\item \ttt{Enter\_Retry\_Num}: Numero di Task in attesa per poter accedere alla risorsa protetta.
		
		\item \ttt{Exit\_Retry\_Num}:  Numero di Task in attesa per poter liberare a risorsa protetta. 
		
		\item \ttt{Train\_Entered\_Per\_Direction}: Numero di Treni transitati per la direzione corrente.
		
	\end{itemize}
	
	Il tipo protetto \ttt{Segment\_Type} fornisce un'interfaccia pubblica accessibile ai Task \ttt{Train\_Executor\_Task} per regolare \ii{ingresso} e \ii{uscita} nel/dal Segmento rappresentato, come descritto nella sezione \label{subsubsec:segment_access}. Di seguito viene riportata una descrizione dettagliata delle \ii{entries} utilizzate.
	
	\subsubsection{Ingresso nel Segmento}
	
	L'ingresso è realizzato mediate l'utilizzo di una entry pubblica \ttt{Enter}, e due entries privare \ttt{Retry\_First\_End} e \ttt{Retry\_Second\_End}.	
	L'entry \ttt{Enter}, permette l'ingresso controllato nel Segmento, e consiste quindi in una barriera.

\begin{lstlisting}
entry Enter(
	To_Add      : in     Positive;
	Max_Speed   : 	 out Positive;
	Leg_Length  :    out Positive) when True is
begin
	...
end Enter;
\end{lstlisting}

	Come prima operazione, esso effettua un controllo sulla direzione con la quale il Treno tenta l'accesso e, se diversa dalle due estremità \ttt{First\_End} e \ttt{Second\_End}, solleva una eccezione.

\begin{lstlisting}
if  (Trains.Trains(To_Add).Current_Station /= First_End) and 
    (Trains.Trains(To_Add).Current_Station /= Second_End) then
	raise Bad_Segment_Access_Request_Exception with "...";
end if;
\end{lstlisting}

Una volta che il controllo è stato superato, viene controllato se il Treno accede dall'estremo \ttt{First\_End} o \ttt{Second\_End}, per poi poter proseguire all'accesso di conseguenza. Viene riportato solo il codice per uno dei due casi, ovvero il caso in cui \ttt{Trains.Trains(To\_Add).Current\_Station = First\_End}, in quanto sono analoghi.

Nel caso in cui il Segmento sia libero (\ttt{Free=True}) allora il Treno può accedere al Segmento.

\begin{lstlisting}

if Free then
	-- Il numero di Treni per direzione viene 
	-- impostato a 1
	Train_Entered_Per_Direction := 1;
	-- Viene impostato ad occupato
	Free := False;
	-- Viene aggiornata la direzione di marcia corrente,
	-- con la Stazione di provenienza del Treno.
	Current_Direction := 
		Trains.Trains(To_Add).Current_Station;
	-- Viene chiusa la guardia booleana dell'entry 
	-- Retry_Second_End. 
	Can_Enter_Second_End := False;
...

\end{lstlisting}

Nel caso in cui invece il Segmento non sia libero, allora viene verificata la possibilità di accesso multiplo, ovvero se e solo se la direzione di percorrenza del Treno è la stessa di quella corrente, se il numero massimo di accessi per direzione (\ttt{Max}) non è stato raggiunto, oppure se nessun Task è accodato all'estremo opposto, ovvero sulla entry \ttt{Retry\_Second\_End}. In tutti gli altri casi il Task corrente viene riaccodato sull'entry \ttt{Retry\_First\_End} che avrà guardia booleana chiusa. Si noti che per il riaccodamento ho utilizzato lo strumento \ttt{requeue} offerto dal linguaggio \ttt{Ada}.

\begin{lstlisting}

...
else
	if Trains.Trains(To_Add).Current_Station = 
	   Current_Direction 
	then
		if Train_Entered_Per_Direction = Max then
			-- Se il numero di accessi e' il massimo 
			-- consentito per direzione...
			if Retry_Second_End'Count > 0 then
				-- se vi sono task in attesa dall'estremo
				-- opposto del Segmento, allora il
				-- task corrente viene accodato presso la 
				-- entry Retry_First_End, in attesa che arrivi
				-- il proprio turno.
				Can_Enter_First_End := False;
				requeue Retry_First_End;
			end if;
		else
			-- se il massimo numero di accessi per 
			-- direzione NON e' stato raggiunto, allora
			-- viene incrementato il numero di accessi
			Train_Entered_Per_Direction := 
				Train_Entered_Per_Direction + 1;
		end if;
	else
		-- nel caso in cui il Treno corrente volesse 
		-- accedere nel senso opposto al senso di 
		-- marcia, dovra' attendere.
		Can_Enter_First_End := False;
		requeue Retry_First_End;
	end if;
end if;
\end{lstlisting}

Se il Task corrente non è stato riaccodato ad un'altra entry, allora viene incrementato di uno il contatore dei Treni in transito, e viene inserito nella coda \ttt{Running\_Trains} l'identificativo del Treno corrente. Vengono infine aggiornati i dati relativi alla velocità di percorrenza (il codice viene omesso per brevità).

	Le entries private \ttt{Retry\_First\_End} e \ttt{Retry\_Second\_End} sono molto simili e sono utilizzate per mantenere accodati i Task relativi ai Treni in attesa di accedere al Segmento, rispettivamente presso l'estremo \ttt{First\_End} e \ttt{Second\_End}. Viene riportato di seguito il codice che realizza l'entry \ttt{Retry\_First\_End}.
	
	\begin{lstlisting}

entry Retry_First_End(
	To_Add     :in		Positive;
	Max_Speed  : 	out Positive;
	Leg_Length :	out	Positive) when Can_Enter_First_End
is
begin
	-- Decremento del numero di Task che 
	-- possono ri-tentare l'accesso
	Enter_Retry_Num := Enter_Retry_Num - 1;
	-- una volta che tale numero e' 0, 
	-- la guardia viene richiusa.
	if Enter_Retry_Num = 0 then
		Can_Enter_First_End := False;
	end if;
	-- il nuovo tentativo viene effettuato ri-accodando
	-- il task corrente presso l'entry Enter.
	requeue Enter;
end Retry_First_End;

	\end{lstlisting}
	
	L'attesa dei task presso questa entry è regolata dalla guardia booleana \ttt{Can\_Enter\_First\_End}, mentre il numero di tentativi di nuovo accesso al Segmento, viene regolato dal parametro \ttt{Enter\_Retry\_Num}.
	
	\subsubsection{Uscita dal Segmento}
	
	L'uscita da un Segmento da parte di un Treno, ha il prerequisito fondamentale per cui esso ha prima avuto accesso a tale Segmento, e quindi il suo identificativo univoco sarà contenuto nella coda \ttt{Running\_Trains}.
	Il processo di uscita garantisce che l'ordine di ingresso sia rispettato, senza possibili assunzioni sull'ordine di esecuzione dei Task coinvolti dato dalle politiche di scheduling sottostanti.
	Esso viene realizzato dalla entry pubblica \ttt{Leave} e dalla entry privata \ttt{Retry\_Leave}.
	
	La entry \ttt{Leave} per prima cosa controlla che il Task correntemente in esecuzione, sia effettivamente il prossimo a dover uscire dal Segmento. Tale controllo viene effettuato confrontando il primo elemento della coda \ttt{Running\_Trains} con l'identificativo del Treno rappresentato dal Task in esecuzione: se essi sono uguali allora l'identificativo viene rimosso dalla coda e viene effettuata l'uscita, altrimenti il Task corrente viene accodato presso l'entry \ttt{Retry\_Leave}.
	
\begin{lstlisting}
	
	entry Leave(
		Train_D : in Positive) when not Free is
	begin
		if Running_Trains.Get(1) = Trains.Trains(Train_D).ID 
		then
			-- il primo elemento della coda viene rimosso
			declare
				T : Positive;
			begin
				Running_Trains.Dequeue(T);
			end;
			...
		else
			-- Requeue alla entry Retry_Leave per
			-- rispettare l'ordine di accesso.
			requeue Retry_Leave;
		end if;
	end Leave;
		
\end{lstlisting}
	 
	L'uscita viene completata nel seguente modo: per prima cosa viene verificata l'eventuale presenza di Task in attesa sulla gardia (chiusa) della entry \ttt{Retry\_Leave};
	
\begin{lstlisting}
	
	...
	-- se c'e' almeno un Task in attesa presso la
	-- guardia di uscita, essa puo' essere aperta
	-- per permettere al prossimo Task di uscire.
	if(Retry_Leave'Count > 0) then
		-- viene memorizzato il numero di task
		-- che possono tentare l'uscita.
		Retry_Num := Retry_Leave'Count;
		Can_Retry_Leave := True;
	end if;
	...
	
\end{lstlisting}
	
	successivamente, viene verificato se il Segmento si è svuotato completamente o meno. Nel primo caso, viene verificata l'eventuale presenza di Treni (Task) in attesa presso l'estremità opposta del Segmento, e in tal caso la loro guardia viene aperta per permettere
di ritentare l'accesso. Nel caso il Segmento sia vuoto ma non vi sia nessun Task in attesa, viene re-impostato il valore di \ttt{Free} a \ttt{True}.

\begin{lstlisting}
	
	...
	-- viene ridotto di 1 il numero di Treni in transito
	Trains_Number := Trains_Number - 1;
	if Trains_Number = 0 then
		-- se il Segmento risulta libero...
		if Current_Direction = First_End then
			-- caso in cui la direzione corrente sia 
			-- proveniente dal primo estremo del segmento.
			if Retry_Second_End'Count > 0 then
				-- se ci sono task in attesa presso la
				-- entry Retry_Second_End, allora essi 
				-- potranno riprovare l'accesso.
				Enter_Retry_Num := Retry_Second_End'Count;
				-- viene aperta la guardia booleana
				Can_Enter_Second_End := True;
				Can_Enter_First_End := False;
			else
				-- se non vi sono treni in attesa, allore
				-- il Segmento viene dichiarato libero.
				Free := True;
			end if;
		else
			-- Caso analogo relativo per la direzione opposta
			...
		end if;
	end if;
	...
	
\end{lstlisting}
	
	Infine, deve essere comunicato l'ordine di uscita alla successiva Stazione. Questa operazione si traduce nell'invocazione della procedura \ttt{Add\_Train} messa a disposizione dall'interfaccia \ttt{Station\_Interface} del package \ttt{Generic\_Station}. 
	
	La entry \ttt{Retry\_Leave} è la seguente:
	
\begin{lstlisting}
	entry Retry_Leave(
		Train_D : in Positive) when Can_Retry_Leave is
	begin
		-- Decremento del numero di task che
		-- possono ritentare l'uscita.
		Retry_Num := Retry_Num - 1;
		-- una volta che tale numero e' 0, 
		-- la guardia viene richiusa per permettere
		-- nuovo accodamento
		if(Retry_Num = 0) then
			Can_Retry_Leave := False;
		end if;
		-- infine viene riaccodato il task corrente
		-- presso Leave, per ritentare l'uscita.
		requeue Leave;
	end Retry_Leave;

\end{lstlisting}

La soluzione presentata sfrutta gli strumenti offerti dal linguaggio Ada per garantire una semantica adeguata di accesso, percorrenza e uscita.

	\subsection{Generic\_Station}
	
	Il package \ttt{Generic\_Station} contiene la definizione dell'interfaccia \ttt{Station\_Interface}, che dovrà essere implementata da tutti i tipi di Stazione. Essa espone i seguenti metodi di classe:
	\begin{description}
		\item \ttt{Enter(\\
			Descriptor\_Index:Integer,\\
			Platform\_Index:Integer,\\
			Segment\_ID:Integer,\\
			Action:Route.Action)} \\
		Metodo invocato dai Task di tipo \ttt{Train\_Task} per poter effettuare l'accesso alla piattaforma \ttt{Platform\_Index} della Stazione.
		
		\item \ttt{Leave(\\
			Descriptor\_Index:Integer,\\
			Platform\_Index:Integer,\\
			Action:Route.Action)} \\
		Metodo invocato dai Task di tipo \ttt{Train\_Task} per poter effettuare la partenza dalla piattaforma \ttt{Platform\_Index} della Stazione.
		
		\item \ttt{Wait\_For\_Train\_To\_Go(\\
			Outgoing\_Traveler:Integer,\\
			Train\_ID:Integer,\\
			Platform\_Index:Integer)} \\
		Metodo utilizzato per posizionare il Viaggiatore di indice \ttt{Outgoing\_Traveler} in attesa del treno \ttt{Train\_ID} presso la Piattaforma \ttt{Platform} per poter partire.		
			
		\item \ttt{Wait\_For\_Train\_To\_Arrive(\\
			Incoming\_Traveler:Integer,\\
			Train\_ID:Integer,\\
			Platform\_Index:Integer)} \\
		Metodo utilizzato per posizionare il Viaggiatore di indice \ttt{Outgoing\_Traveler} in attesa del treno \ttt{Train\_ID} presso la Piattaforma \ttt{Platform} per simulare la percorrenza all'interno del Treno \ttt{Train\_ID}.
			
		\item \ttt{Add\_Train(\\
			Train\_ID:Integer,\\
			Segment\_ID:Integer)} \\
		Metodo utilizzato per poter definire l'ordine di arrivo di un Treno \ttt{Train\_ID} proveniente dal Segmento \ttt{Segment\_ID}.	
	
		\item \ttt{Buy\_Ticket(\\
			Traveler\_Index:Integer,\\
			To:String)} \\
		Metodo che permette ad un viaggiatore \ttt{Traveler} di poter effettuare una richiesta per ottenere un Ticket per la destinazione \ttt{To}.
	\end{description}
	
	Il package contiene, oltre all'interfaccia descritta, anche la definizione del tipo protetto \ttt{Access\_Controller}. Questo tipo di risorsa protetta viene utilizzata dalle Stazioni per regolare l'ordine di richiesta d'accesso alle Piattaforme, in base all'ordine di uscita dal Segmento al quale tale risorsa fa riferimento. \ttt{Access\_Controller} mantiene una coda \ttt{Trains\_Order} di identificativi di Treni, di tipo \ttt{Unlimited\_Simple\_Queue}, alla quale è possibile aggiungere elementi mediante la procedura protetta esposta \ttt{Add\_Train}. Esso inoltre espone l'entry \ttt{Enter(Train\_Index:Integer)} con guardia sempre aperta (\ttt{True}) per permettere il primo tentativo di accesso, che avviene soltanto se il primo elemento della coda coincide con l'identificativo del Treno corrente. Nel caso il Treno non sia il prossimo secondo l'ordine definito da \ttt{Trains\_Order}, allora il task corrente viene posto in attesa su guardia presso l'entry privata \ttt{Wait}, mediante il costrutto \ttt{requeue}. La procedure \ttt{Free} rimuove dalla coda il primo elemento, e, nel caso in cui vi siano Task in coda sulla guardia presso l'entry \ttt{Wait}, apre tale guardia in modo tale da permettere ad essi di ritentare l'accesso.
	
	\subsection{Generic\_Platform}
	
	Il package \ttt{Generic\_Platform} definisce l'interfaccia di classe \ttt{Platform\_Interface} implementata da ciascun tipo rappresentante una Piattaforma.
	
	\subsection{Platform} 
	
	Il package \ttt{Platform} definisce il tipo protetto \ttt{Platform\_Type}, usato per regolare gli accessi alla Piattaforma. Esso mantiene i campi dato:
	\begin{itemize}
		\item \ttt{Free}: Variabile booleana usata per indicare lo stato di occupazione della Piattaforma.

		\item \ttt{Can\_Retry}: Variabile booleana usata come guardia per regolare i tentativi di accesso alla Piattaforma.

		\item \ttt{Retry\_Count}: Variabile a valori interi usata per la regolazione dei tentativi di accesso alla Piattaforma.
		
		\item \ttt{Trains\_Order}: Coda di interi FIFO, di tipo \ttt{Unlimited\_Simple\_Queue}, usata per memorizzare gli identificativi dei Treni che intendono accedere alla Piattaforma.
	\end{itemize}
	\ttt{Platform\_Type} si compoene delle seguenti procedure:
	
	\begin{description}
		
		\item \ttt{Add\_Train(Train\_ID:Integer)} \\
		Aggiunge l'identificativo \ttt{Train\_ID} nella coda \ttt{Trains\_Order}.
		
		\item \ttt{Leave} \\
		Imposta il campo \ttt{Free} a \ttt{False} liberando la risorsa, e, nel caso in cui ci fossero Task in attesa presso la \ii{entry} \ttt{Retry}, apre la guardia \ttt{Can\_Retry} memorizzando il numero di tali task nel campo \ttt{Retry\_Count}.
		
	\end{description}
	e delle seguenti \ii{entries}:
	\begin{description}
		
		\item \ttt{Enter(Train\_Descriptor\_Index:Integer)}\\
		Ha guardia booleana sempre aperta (\ttt{True}). Essa verifica se il primo elemento della coda corrisponde al Treno corrente. In tal caso viene permesso l'accesso viene impostato lo stato della Piattaforma ad occupato (\ttt{Free = False}). Nel caso in cui invece tale condizione non si verifichi, il Task corrente viene riaccodato sulla \ii{entry} \ttt{Retry}.	
		
		\item \ttt{Retry(Train\_Descriptor\_Index:Integer)}\\
		\'E regolata dalla guardia booleana \ttt{Can\_Retry}. Essa decrementa il valore di \ttt{Retry\_Count} e, nel caso in cui esso sia a 0, imposta il valore di \ttt{Can\_Retry} a \ttt{False}. Infine riaccoda il Task corrente presso la entry \ttt{Enter}.
		
	\end{description}
	
	Il package \ttt{Platform} definisce inoltre il tipo \ii{tagged} \ttt{Platform\_Handler}. Esso contiene un oggetto di tipo \ttt{Platform\_Type}, \ttt{The\_Platform}, e implementa i metodi dell'interfaccia \ttt{Platform\_Interface}:
	\begin{description}
		
		\item \ttt{+ Enter(\\
			Train\_Descriptor\_Index:Integer,\\
			Action:Route.Action)}\\
		Per prima cosa cerca di ottenere l'accesso alla Piattaforma mediante l'\ii{entry} \ttt{Enter} invocata sull'oggetto \ttt{The\_Platform}, poi notifica l'avvenuto accesso al Controller Centrale e invoca il metodo privato \ttt{Perform\_Entrance} per effettuare le operazioni necessarie all'arrivo del Treno.
		
		\item \ttt{+ Leave(\\
			Train\_Descriptor\_Index:Integer,\\
			Action:Route.Action)}\\
		Invoca il metodo privato \ttt{Perform\_Exit} per effettuare le operazioni necessarie all'uscita del Treno dalla Piattaforma, e successivamente invoca la procedura protetta \ttt{Leave} sull'oggetto \ttt{The\_Platform}.
		
	\end{description}
	
	\subsection{Regional\_Station}
	
	Il package \ttt{Regional\_Station} contiene la definizione del tipo classe (\ttt{tagged} nel linguaggio Ada) \ttt{Regional\_Station\_Type} il quale implementa l'interfaccia \ttt{Station\_Interface}. Ciascuna istanza di classe \ttt{Regional\_Station} contiente una tabella di hash, \ttt{Segments\_Map\_Order}, la quale per ciascun Segmento entrante associa un'istanza di \ttt{Access\_Controller}; inoltre, essa contiene un array di oggetti di tipo \ttt{Platform\_Type} (ovvero Piattaforme), in numero definito da configurazione, e una istanza di oggetto \ttt{Notice\_Panel}. 
	Ciascuna Stazione fornisce quindi da interfaccia all'esterno per l'accesso alle componenti interne.
	
	Le operazioni svolte del metodo \ttt{Enter} sono le seguenti:
	\begin{itemize}
	
		\item Viene effettuato l'accesso alla Stazione, mantenendo l'ordine di uscita dal Segmento.

\begin{lstlisting}
...
This.Segments_Map_Order.Element(Segment_ID).Enter(
		Train_Index	=> Descriptor_Index);
...
\end{lstlisting}
		\item Una volta ottenuto l'accesso, il Task corrente aggiunge l'identificativo del descrittore presso la coda interna alla piattaforma che regola l'ordine di ingresso in essa.
		Si noti che questa invocazione di procedura viene eseguita in modo concorrente tra tutti i Treni provenienti da Segmenti diversi che vogliono accedere alla stessa piattaforma, ma in mutua esclusione tra tutti quelli che provengono dallo stesso Segmento.
\begin{lstlisting}
...
This.Platforms(Platform_Index).Add_Train(
		Trains.Trains(Descriptor_Index).ID);
...
\end{lstlisting}
		\item Una volta che il descrittore è stato aggiunto alla coda interna alla piattaforma desiderate, il controller degli accessi alla Stazione può essere rilasciato, poiché l'ordine di accesso alla Stazione è garantito.
\begin{lstlisting}
...
This.Segments_Map_Order.Element(Segment_ID).Free;
...
\end{lstlisting}
		\item Viene richiesto l'accesso vero e proprio alla Piattaforma che avverrà secondo l'ordine definito dalla propria coda interna.
\begin{lstlisting}
...
This.Platforms(Platform_Index).Enter(
		Train_Descriptor_Index 	=> Descriptor_Index,
		Action					=> Action);
...
\end{lstlisting}
		\item Notifica al pannello informativo dell'avvenuto ingresso del Treno alla Piattaforma.
\begin{lstlisting}
...
This.Panel.Set_Train_Accessed_Platform(
		Train_ID	=> Trains.Trains(Descriptor_Index).ID,
		Platform 	=> Platform_Index);
...
\end{lstlisting}
	\end{itemize}
	
	Il metodo \ttt{Leave} si limita a liberare la Piattaforma desiderata mediante l'invocazione su di essa della procedura protetta \ttt{Leave}, e a notificare l'avvenuta dipartita del Treno al Pannello informativo della Stazione.
	
	I metodi ridefiniti \ttt{Wait\_For\_Train\_To\_Go} e \ttt{Wait\_For\_Train\_To\_Arrive} aggiungono l'indice del Viaggiatore passato come parametro nelle code interne alla Piattaforma riservate alla partenza e all'arrivo dei Viaggiatori rispettivamente. 
	
	La ridefinizione del metodo \ttt{Add\_Train} aggiunge l'identificativo del Treno passato come parametro alla coda interna al controllore di accessi creato per il Segmento di origine del Treno. Se tale controllore non esiste (la creazione avviene non per tutti i Segmenti in ingresso ma solo se essi sono effettivamente utilizzati) viene creato, e aggiunto quindi alla tabella \ttt{Segments\_Map\_Order}.
	
	Infine, la ridefinizione del metodo \ttt{Buy\_Ticket} effettua una invocazione della procedure \ttt{Get\_Ticket} del package \ttt{Regional\_Ticket\_Office}.
	
	\subsection{Gateway\_Station}
	
	Il package \ttt{Gateway\_Station} contiene la definizione del tipo \ii{tagged} \ttt{Gateway\_Station\_Type}, il quale implementa l'interfaccia \ttt{Station\_Interface}. Il tipo \ttt{Gateway\_Station\_Type} contiene, come \ttt{Regional\_Station\_Type}, un array di oggetti di tipo \ttt{Platform\_Type}, una mappa \ttt{Segments\_Map\_Order} contenente per ogni Segmento il controllore di accessi (\ttt{Access\_Controller}) relativo, e un oggetto di tipo \ttt{Notice\_Panel\_Type}, che rappresenta il pannello informativo della Stazione.
	L'implementazione dei metodi astratti, è molto simile a quella fornita dal tipo \ttt{Regional\_Station}; di seguito verranno descritte le differenze principali:
	\begin{itemize}
		
		\item Il metodo \ttt{Enter} esegue le operazioni descritte per l'equivalente metodo esposto da \ttt{Regional\_Station}. Vi è però la possibilità che il Treno corrente possa essere trasferito su un Nodo diverso, se previsto dal percorso. A tal proposito, dopo aver avuto accesso alla Piattaforma desiderata, vengono recuperati, se previsti dal percorso, la prossima stazione da raggiungere e il Nodo, ovvero la regione, sulla quale essa si trova. Per come un percorso è definito, la prossima stazione sarà la relativa Stazione di Gateway nel Nodo della tappa successiva a quella corrente. L'eventuale trasferimento del Treno viene effettuato mediante la procedura \ttt{Send\_Train}, esposta dal package \ttt{Remote\_Station\_Interface}.
		
		\item Il metodo \ttt{Leave} una volta liberata la Piattaforma indicata dal parametro \ttt{Platform\_Index}, controlla se il Treno proviene da un Nodo diverso da quello corrente. In questo caso, viene inviata un messaggio al Nodo di provenienza per comunicare l'avvenuta dipartite del Treno dalla Piattaforma con la procedura \ttt{Train\_Left\_Message} esposta da \ttt{Remote\_Station\_Interface}.
		
		\item Il metodo \ttt{Wait\_For\_Train\_To\_Go} controlla se la tappa successiva nel Ticket del Viaggiatore indicato da \ttt{Outgoing\_Traveler} porta in una Stazione appartenente ad un Nodo diverso da quello corrente. In tal caso viene invocata la procedura \ttt{Send\_Traveler\_To\_Leave} del package \ttt{Remote\_Station\_Interface} per far attendere il Viaggiatore presso la Piattaforma della Stazione di Gateway corrente appartenente a tale Nodo.
		
	\end{itemize}
	
	
	
